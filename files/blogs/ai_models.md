---
key: ai_models
title: Choosing the Right AI Model for the Job
description: A personal, practical comparison of AI models I actually useâ€”optimized for speed, depth, and async workflows.
---

# Choosing the Right AI Model for the Job

## Fast edits, long runs, and async by default

One thing Iâ€™ve learned the hard way: **AI models are tools, not magic**. Treating them all the same is an easy mistakeâ€”and a costly one in terms of time and mental overhead.

Below is how I currently think about a few models I use regularly, and *why* I reach for each one.

---

<details>
<summary><strong>âš¡ Composer 1 â€” Fast Edits & Tight Feedback Loops</strong></summary>

<br />

Composer 1 is my default when speed matters more than depth.

**I use it for:**

- Quick copy edits  
- Small code tweaks  
- Rapid iteration when I already know the direction  

Itâ€™s responsive, lightweight, and keeps momentum high. When Iâ€™m in â€œediting modeâ€ rather than â€œthinking mode,â€ this is the right fit.

</details>

---

<details>
<summary><strong>ğŸ§  Codex 5.1 â€” Long-Running, Heavy-Lift Tasks</strong></summary>

<br />

Codex 5.1 is what I use when I need the model to *sit with a problem*.

**I use it for:**

- Larger or messier codebases  
- Multi-step refactors  
- Tasks that require sustained context and structure  

Itâ€™s slower, but intentionally so. For work where correctness, planning, and coherence matter more than raw speed, Codex 5.1 earns its place.

</details>

---

<details>
<summary><strong>ğŸ”„ Linear Background Agents â€” Async Workflows</strong></summary>

<br />

Not everything needs to block my attention. Thatâ€™s where linear background agents come in.

**I use them for:**

- Asynchronous research  
- Parallel analysis  
- Tasks that can run while I focus elsewhere  

This mirrors how I already prefer to work: queue things up, let them run, and check in when theyâ€™re ready.

</details>

---

## Final Thoughts

Thereâ€™s no single â€œbestâ€ AI modelâ€”only better matches for specific kinds of work. Once I started choosing models more deliberately, my workflows became faster, calmer, and far more predictable.

Less friction. Better output. Fewer interruptions.

Thatâ€™s the real win.

